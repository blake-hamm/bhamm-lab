apiVersion: v1
kind: ServiceAccount
metadata:
  name: k8up-backup-workflow-sa
  namespace: k8up
---
# Role for permissions in the k8up namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: k8up-backup-workflow-role
  namespace: k8up
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]
  - apiGroups: ["argoproj.io"]
    resources: ["workflows", "workflows/finalizers"]
    verbs: ["create", "delete", "get", "list", "patch", "update", "watch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["create", "delete", "get", "list", "patch", "update", "watch"]
---
# Role for permissions in the example namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: k8up-backup-workflow-role
  namespace: example
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "delete", "get", "list", "patch", "update", "watch"]
  - apiGroups: ["k8up.io"]
    resources: ["backups", "backups/status", "backups/finalizers"]
    verbs: ["create", "delete", "get", "list", "patch", "update", "watch"]
---
# RoleBinding for the k8up namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: k8up-backup-workflow-rolebinding
  namespace: k8up
subjects:
  - kind: ServiceAccount
    name: k8up-backup-workflow-sa
    namespace: k8up
roleRef:
  kind: Role
  name: k8up-backup-workflow-role
  apiGroup: rbac.authorization.k8s.io
---
# RoleBinding for the example namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: k8up-backup-workflow-rolebinding
  namespace: example
subjects:
  - kind: ServiceAccount
    name: k8up-backup-workflow-sa
    namespace: k8up
roleRef:
  kind: Role
  name: k8up-backup-workflow-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  name: example-backup
  namespace: k8up
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "20"
spec:
  serviceAccountName: k8up-backup-workflow-sa
  entrypoint: main
  templates:
    - name: main
      steps:
        - - name: generate-secret
            template: generate-secret
        - - name: run-backup
            template: run-backup
        - - name: cleanup
            template: cleanup
    # Step 1: Generate temporary credentials
    - name: generate-secret
      script:
        image: google/cloud-sdk:latest
        command: [bash]
        source: |
          set -e

          # debug
          ls -la /secrets

          echo "Activating service account using the service-account.json..."
          gcloud auth activate-service-account --key-file=/secrets/service-account.json

          echo "Generating temporary access token..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)

          echo "Extracting project_id from service-account.json..."
          PROJECT_ID=$(cat /secrets/project_id)

          echo "Creating secret 'gcs-backup-temp' in the 'example' namespace..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: gcs-backup-temp
            namespace: example
          type: Opaque
          stringData:
            project_id: "$PROJECT_ID"
            accessToken: "$ACCESS_TOKEN"
          EOF

          # Verify the secret was created
          if ! kubectl get secret gcs-backup-temp -n example &>/dev/null; then
            echo "Failed to create secret" >&2
            exit 1
          fi
        volumeMounts:
          - name: gcp-sa
            mountPath: /secrets
    # Step 2: Run a one-time backup
    - name: run-backup
      script:
        image: bitnami/kubectl:latest
        command: [bash]
        source: |
          echo "Triggering a point-in-time backup..."
          BACKUP_NAME="backup-to-gcs-$(date +%s)"
          cat <<EOF | kubectl apply -f -
          apiVersion: k8up.io/v1
          kind: Backup
          metadata:
            name: $BACKUP_NAME
            namespace: example
            labels:
              app: k8up-backup
          spec:
            repoPasswordSecretRef:
              name: example-external-secret
              key: k8up-repo-password
            backend:
              gcs:
                bucket: "your-gcs-bucket-name"  # Replace with your target GCS bucket name
                projectIDSecretRef:
                  name: gcs-backup-temp
                  key: project_id
                accessTokenSecretRef:
                  name: gcs-backup-temp
                  key: accessToken
            promURL: "http://prometheus:9090"  # Optional: for metrics
          EOF

          echo "Waiting for backup $BACKUP_NAME to start..."
          kubectl wait --for=condition=Started --timeout=60s backup/$BACKUP_NAME -n example || true

          echo "Backup job initiated. You can check the status with:"
          echo "kubectl get backup $BACKUP_NAME -n example -o wide"
    # Step 3: Clean up the temporary secret after backup is triggered
    - name: cleanup
      script:
        image: bitnami/kubectl:latest
        command: [bash]
        source: |
          echo "Waiting for backup to complete (this might take some time)..."
          # Add a reasonable timeout based on your backup size
          sleep 60

          echo "Cleaning up temporary GCP credentials secret..."
          kubectl delete secret gcs-backup-temp -n example

          echo "Backup process complete. The backup will continue in the background."
          echo "Check the status with: kubectl get backups -n example"
  volumes:
    - name: gcp-sa
      secret:
        secretName: gcp-k8up-sa
