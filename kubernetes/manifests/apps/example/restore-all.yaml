apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  name: example-restore
  namespace: k8up
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "20"
spec:
  serviceAccountName: k8up-backup-workflow-sa
  entrypoint: main
  templates:
    - name: main
      steps:
        - - name: generate-secret
            template: generate-secret
        - - name: run-backup
            template: run-backup
        - - name: cleanup
            template: cleanup
    # Step 1: Generate temporary credentials
    - name: generate-secret
      script:
        image: google/cloud-sdk:latest
        command: [bash]
        source: |
          set -e

          echo "Activating service account using the service-account.json..."
          gcloud auth activate-service-account --key-file=/secrets/service-account.json

          echo "Generating temporary access token..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)

          echo "Extracting project_id from service-account.json..."
          PROJECT_ID=$(cat /secrets/project_id)

          echo "Creating secret 'gcs-backup-temp' in the 'example' namespace..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: gcs-backup-temp
            namespace: example
          type: Opaque
          stringData:
            project_id: "$PROJECT_ID"
            accessToken: "$ACCESS_TOKEN"
          EOF

          # Verify the secret was created
          if ! kubectl get secret gcs-backup-temp -n example &>/dev/null; then
            echo "Failed to create secret" >&2
            exit 1
          fi
        volumeMounts:
          - name: gcp-sa
            mountPath: /secrets
    # Step 2: Run a one-time backup
    - name: run-backup
      script:
        image: bitnami/kubectl:latest
        command: [bash]
        source: |
          set -e

          echo "Triggering a point-in-time backup..."
          BACKUP_NAME="backup-to-gcs-$(date +%s)"
          cat <<EOF | kubectl apply -f -
          apiVersion: k8up.io/v1
          kind: Restore
          metadata:
            name: restore-example
            namespace: example
          spec:
            restoreMethod:
              folder:
                claimName: example
            backend:
              repoPasswordSecretRef:
                name: example-external-secret
                key: k8up-repo-password
              gcs:
                bucket: bhamm-lab-k8up
                projectIDSecretRef:
                  name: gcs-backup-temp
                  key: project_id
                accessTokenSecretRef:
                  name: gcs-backup-temp
                  key: accessToken
            podSecurityContext:
              fsGroup: 0
              runAsUser: 0
          EOF

          # echo "Waiting for backup $BACKUP_NAME to start..."
          # kubectl wait --for=jsonpath='{.status.started}'=true \
          #   backup/$BACKUP_NAME -n example \
          #   --timeout=60s || true

          # echo "Backup job initiated. You can check the status with:"
          # echo "kubectl get backup $BACKUP_NAME -n example -o wide"
    # Step 3: Clean up the temporary secret after backup is triggered
    - name: cleanup
      script:
        image: bitnami/kubectl:latest
        command: [bash]
        source: |
          set -e

          # echo "Waiting for backup to complete (this might take some time)..."
          # kubectl wait --for=jsonpath='{.status.finished}'=true \
          #   re/$BACKUP_NAME -n example || true

          # echo "Cleaning up temporary GCP credentials secret..."
          # kubectl delete secret gcs-backup-temp -n example

          echo "Backup process complete. The backup will continue in the background."
          echo "Check the status with: kubectl get backups -n example"
  volumes:
    - name: gcp-sa
      secret:
        secretName: gcp-k8up-sa
