apiVersion: v1
kind: ServiceAccount
metadata:
  name: garage-bootstrap
  namespace: garage
  annotations:
    argocd.argoproj.io/sync-wave: "2"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: garage-bootstrap-role
  namespace: garage
  annotations:
    argocd.argoproj.io/sync-wave: "2"
rules:
  # allow reading the pod and exec into it
  - apiGroups: [""]
    resources: ["pods", "pods/exec"]
    verbs: ["get", "list", "create"]
    # allow creating/updating the S3 creds secret
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: garage-bootstrap-binding
  namespace: garage
  annotations:
    argocd.argoproj.io/sync-wave: "2"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: garage-bootstrap-role
subjects:
  - kind: ServiceAccount
    name: garage-bootstrap
    namespace: garage
---
apiVersion: batch/v1
kind: Job
metadata:
  name: garage-bootstrap-create-cred
  namespace: garage
  annotations:
    argocd.argoproj.io/sync-wave: "3"
spec:
  backoffLimit: 1
  template:
    spec:
      serviceAccountName: garage-bootstrap
      restartPolicy: OnFailure
      containers:
        - name: bootstrap
          image: bitnami/kubectl:latest
          command: ["/bin/sh", "-eux", "-c"]
          args:
            - |
              # 1) Create admin user
              kubectl exec -n garage garage-0 -- \
                ./garage key create admin

              # # 2) extract keyId & secretKey
              # ACCESS_KEY=$(echo "$CREDS_JSON" | jq -r .keyId)
              # SECRET_KEY=$(echo "$CREDS_JSON" | jq -r .secretKey)

              # # 3) create/update the k8s Secret
              # kubectl create secret generic garage-s3-creds \
              #   -n garage \
              #   --from-literal=accessKey="$ACCESS_KEY" \
              #   --from-literal=secretKey="$SECRET_KEY" \
              #   --dry-run=client -o yaml \
              # | kubectl apply -f -
